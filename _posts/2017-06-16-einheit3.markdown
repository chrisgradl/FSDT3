---
layout: default
title:  "Lesson 3: Arduino -> Node"
date:   2017-06-16 08:00:00
categories: main
---

# Sensor Display App

Today we are building a node application which reads in the sensor data from the arduino and displays it on a website:

![FSDT3 Architecture]({{ site.url }}/fsdt3/img/goal.gif)

The main building blocks of our app:
![FSDT3 Architecture]({{ site.url }}/fsdt3/img/fsdt3_architecture.png)

## How to get Data from the Arduino to our Node Appliction and then to our website?

We will use a 3rd party module called serialport to read the sensor data in from the Arduino.

## How to display the data on a website?

We will use the socket.io module to send the data from the node application to the website

### TASK: Get Data from the Arduino:

Depending on your current progress you should already print out sensor values in the serial log in the arduino IDE. If not please deploy following code to your arduino.

<script src="https://gist.github.com/chrisgradl/b2b7ebea853982c814a238cf730e1cff.js"></script>

### TASK: Create the sensorvis application

* create the dir sensorvis and switch into it on the command line
* create a new npm project
* add the following dependencies to the project with the --save flag
  * express
  * serialport
  * socketio
* check if all dependencies were added in the package.json file
* create the directory 'public' and put the  hmtl file sensorvis.html into it
* Then use express to return this file on your '/' route. Use the code from the last session if you need help.



## Read in the arduino data stream
The Sensor values will be read from the serial port of the USB interface of the arduino board. We will use the library [node-serialport] for it.

{% highlight json %}
{timestamp: 387709, type: "heart rate sensor raw", unit: "raw", value: 500}
{timestamp: 387710, type: "heart rate sensor bpm", unit: "bpm", value: 35}
{timestamp: 387720, type: "heart rate sensor raw", unit: "raw", value: 494}
{timestamp: 387721, type: "heart rate sensor bpm", unit: "bpm", value: 35}
{timestamp: 387730, type: "heart rate sensor raw", unit: "raw", value: 486}
{% endhighlight %}

To read the data in we have to do following steps:
* Load the seriaport module
* list the possible inputs to read from with the list function
* create a new serialPort with the portname of our arduino
* 


{% highlight javascript %}
serialport.list(function(err, ports) {

  ports.forEach(function(port) {
      console.log(port);
  });
});
{% endhighlight %}


Wenn wir jetzt unser script starten wird auf der Command Line die Anschlüsse angezeigt.
Hier suchen wir den Arduino und legen eine Variable mit dem entsprechenden comNamen an:

Mac & Linux zB:
{% highlight javascript %}
var portName = '/dev/cu.usbmodem1421';
{% endhighlight %}

Für Windows zB:
{% highlight javascript %}
var portName = 'COM3';
{% endhighlight %}

Anschließend verbinden wir uns mit dem Arduino

{% highlight javascript %}
var arduinoPort = new serialport.SerialPort(portName, {
    baudrate: 9600,
    parser: serialport.parsers.readline("\r\n")
});
{% endhighlight %}

Jetzt erstellen wir Funktionen die bei den unterschiedlichen Events der serialport library aufgerufen werden:
{% highlight javascript %}
arduinoPort.on('open', function() {
  //ich werde aufgerufen wenn wir uns mit dem Arduino verbinden
});
{% endhighlight %}

Wir erstellen eine Funktion die beim Empfangen von neuen Daten aufgerufen wird:

{% highlight javascript %}
arduinoPort.on('data', function(data) {
      // i am called everytime a new line is sent from the arduino
      // data is read as String so we parse it to get a JSON Object
      // wrap it in try catch block in case line is parsed not correct#
      try{
        var obj = JSON.parse(data);
        console.log(obj.value);
      }catch(e){
        console.log(e);
      }

});
{% endhighlight %}

### Parse Error
In der Übung ist immer wieder ein Error aufgetreten beim Einlesen der Daten. Daher muss man die Json.parse() Funktion in einen try -catch Block setzten um den Error abfangen zu können

## 2. Senden der Daten an eine Webanwendung

Um die Daten nun visualisieren zu können werden diese zu einem Javascript Client übertragen

Folgende Technologien verwenden wir:

* [Socket.io] bzw WebSockets zum Übertragen der Daten
* [Express] um die Webanwendug in unserer Node.js Applikation zu hosten
* [Smoothie.js] für eine Echtzeit-Visualiserung

Zu unserem index.js file müsen wir die notwendigen Komponenten hinzufügen. Dazu installieren wir Express und Socket.io
Dazu führen wir folgende Commands in unserem Projektverzeichnis aus:

{% highlight javascript %}
npm install express --save
npm install socket.io --save
{% endhighlight %}  

Anschließend erweitern wir unsere Node Anwendung um einen express und socket.io server:

{% highlight javascript %}
var express = require('express');
var app = express();
var http = require('http').Server(app);
var socketio = require('socket.io')(http);
{% endhighlight %}  

Wie funktioniert das Laden von Modulen? Hier eine [Erklärung zu Module]

Mit einer Http Get Route können wir überprüfen ob der Server richtig läuft:
{% highlight javascript %}

// return a Hello World Message when the base url is requested
app.get('/', function (req, res){
    res.send('<h1>Hello world</h1>');
  });

//start the server at port 3000
http.listen(3000);
{% endhighlight %}

Starten wir jetzt unsere Anwendung neu und wechseln auf die [Seite] bekommt man Hello World zurück

Jetzt wollen wir die entsprechenden Daten über Socket.io zum Client verschicken:  

{% highlight javascript %}
socketio.on('connection', function(socket) {
    console.log("WebSocket connected");
    //start to read the data from the arduino and send to connected client
    arduinoPort.on('data', function(data) {
      try{
        var obj = JSON.parse(data);
          socket.emit('data', obj);
      }catch(e){
        console.log(e);
      }

    });
});
{% endhighlight %}


## 3. Erstellen der Webanwendug

Wir erstellen in unserem Projektordner einen Subordner mit dem Namen 'client'. In diesem legen wir ein index.html und ein client.js file an.
Um die index.html Seite vom Node-Server abrufen zu können passen wir unsere index.js script an:
{% highlight javascript %}
app.get('/', function (req, res){
    res.sendFile(\__dirname + "/client/index.html");
  });

{% endhighlight %}

Der Server muss außerdem die Files im Ordner /client verfügbar machen. So können die Scripts in dem index.html file geladen werden.
{% highlight javascript %}
app.use(express.static(\__dirname + "/client"));
{% endhighlight %}

Jetzt können wir die Webanwendung programmieren. Dazu binden wir folgende Scripts in unser Html File ein:

{% highlight javascript %}
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript" src="/client.js"></script>
{% endhighlight %}

In unserem client.js file erstellen wir nun einen socket.io Client und eine Funktion zum Empfangen der Daten

{% highlight javascript %}
var socket = io();

socket.on('data', function(msg) {
    console.log(msg);
});
{% endhighlight %}

In der Konsole im Browser werden jetzt die Werte vom Arduino geprintet

### Echtzeit-Visualiserung mit smoothiecharts

Jetzt können wir die Daten visualisieren. Hierzu verwenden wir [Smoothie.js].

Dazu legen wir einen lib Folder an (/client/lib/) und kopieren den [Code für die Library] in ein neues File smoothie.js
Anschließend binden wir noch das script in unser index.html file ein.

In unserem index.html File erstellen wir nun ein neues Element auf dem die Visualisierung gezeichnet wird:
{% highlight html %}
    <canvas id="mycanvas" width="800" height="200"></canvas>
{% endhighlight %}


Im client.js File erstellen wir ein neues Smoothie.js Objekt. Mit der streamto methode setzten wir das element auf welchem  smoothie.js die Visualisierung zeichnet. Außerdem erstellen wir ein neues Objekt vom Typ TimeSeries.

{% highlight javascript %}
var smoothie = new SmoothieChart();
smoothie.streamTo(document.getElementById("mycanvas"));

var line1 = new TimeSeries();
smoothie.addTimeSeries(line1);   
{% endhighlight %}

Um jetzt neue Werte zu zeichnen, müssen diese an das line1 Objekt angefügt werden. Das machen wir in dem socket.io Callback
{% highlight javascript %}
socket.on('data', function(msg) {
    console.log(msg);
    //we only want to visualize the raw sensor value
    if (msg.unit == 'raw') {
        line1.append(new Date().getTime(), msg.value);
    }
});
{% endhighlight %}

### Danger Alert! Mein Arduino geht nicht Was jetzt???
Falls der Arduino aus irgendeinem Grund nicht verfügbar ist oder nicht funktioniert gibt es die Möglichkeit Random Daten von der Node Applikation zum Client zu schicken
Dazu erstellen folgende Funktion:

{% highlight javascript %}
var sensorJson = JSON.parse('{"timestamp": 19123,"type": "heart rate sensor raw","unit": "raw","value": 987}');
function sendRandomData(socket) {
    setInterval(function() {
        sensorJson.value = Math.random();
        socket.emit('data', sensorJson);
    }, 100);
}
{% endhighlight %}

Diese Funktion muss man dann in dem 'connection' Callback aufrufen wenn sich der Client verbindet


So wir haben jetzt die Daten eingelesen und auch zum Client geschickt und visualisiert. Für viele Anwendungen ist es jedoch auch spannend die Sensorwerte in einem File zu speichern und zu einem späteren Zeitpunkt weiterzuverarbeiten.

### Hausübung:

Erweitere unsere Node.js Applikation um eine Funktion zum Speichern der 'raw' Sensorwerte.
Sobald sich der Server mit dem Arduino verbindet sollen die Werte in ein File gespeichert werden. (CSV oder JSON).
Dazu kann das bestehende Projekt einfach umgeändert werden. Das ganze soll ohne Client  funktionieren. Die socket.io und express teile können also gelöscht werden.

Die [FileSystem Komponente] von Node soll dazu verwendet werden

[node-serialport]: https://github.com/voodootikigod/node-serialport/
[Smoothie.js]: http://smoothiecharts.org/
[Express]: http://expressjs.com/
[Socket.io]: http://socket.io
[Seite]: http://localhost:3000/
[Websocket Anwendung]: http://www.websocket.org/echo.html
[Erklärung zu Module]: http://openmymind.net/2012/2/3/Node-Require-and-Exports/
[Code für die Library]:  https://raw.githubusercontent.com/joewalnes/smoothie/master/smoothie.js
[FileSystem Komponente]: https://nodejs.org/api/fs.html#fs_fs_appendfile_file_data_options_callback
